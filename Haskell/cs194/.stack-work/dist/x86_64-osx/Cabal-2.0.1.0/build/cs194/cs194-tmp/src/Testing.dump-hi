
==================== FINAL INTERFACE ====================
2018-04-06 14:43:43.170974 UTC

interface main:Testing 8022
  interface hash: ee226349a58d79aed717cbb25ea64450
  ABI hash: 5b79301c6646b9738a5538cc1b5ecdad
  export-list hash: 6d3bbb09d4ec6265b177f1832b4c4dbb
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 9ec6e7dc447ce0d70c26e5d3bf1e593e
  sig of: Nothing
  used TH splices: False
  where
exports:
  Testing.runTest
  Testing.runTests
  Testing.testF1
  Testing.testF2
  Testing.testF3
  Testing.Failure{Testing.Fail}
  Testing.Test{Testing.Test}
module dependencies:
package dependencies: base-4.10.1.0* ghc-prim-0.5.1.1
                      integer-gmp-1.0.1.0
orphans: base-4.10.1.0:GHC.Float base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Either base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Type.Equality base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats
import  -/  base-4.10.1.0:Control.Arrow b4ff99f516cf3ba87a1e4985dc7f496f
import  -/  base-4.10.1.0:Data.Maybe 07738c5485acb328136bb15596f8b845
import  -/  base-4.10.1.0:Data.Tuple 8fa1305aa5032ea35e2a54fa5f1e78f9
import  -/  base-4.10.1.0:GHC.Base 782fd99b5e36f3698a26179a49afca64
import  -/  base-4.10.1.0:GHC.List e3060fbeb44ce0038e6b4dedf2dd9cf1
import  -/  base-4.10.1.0:GHC.Show 0a8ce2b5e533d1c2cfb7954e6736be45
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
import  -/  ghc-prim-0.5.1.1:GHC.Classes 93e2660065dce9329577e83d76d8f0d4
82fbd8555978daa52f6e486901d331c9
  $fShowFailure :: GHC.Show.Show Testing.Failure
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Testing.Failure
                  Testing.$fShowFailure_$cshowsPrec
                  Testing.$fShowFailure_$cshow
                  Testing.$fShowFailure_$cshowList -}
82fbd8555978daa52f6e486901d331c9
  $fShowFailure1 ::
    Testing.Failure -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ (x :: Testing.Failure)
                   (s :: GHC.Base.String)[OneShot] ->
                 case x of wild { Testing.Fail a $dShow s1 as ->
                 GHC.CString.unpackAppendCString#
                   Testing.$fShowFailure3
                   (GHC.Base.++
                      @ GHC.Types.Char
                      s1
                      (GHC.CString.unpackAppendCString#
                         Testing.$fShowFailure2
                         (GHC.Base.++
                            @ GHC.Types.Char
                            (GHC.Show.showList @ a $dShow as (GHC.Types.[] @ GHC.Types.Char))
                            s))) }) -}
fc32b23ce59f553aa512afed9ce2cfb2
  $fShowFailure2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\" on inputs "#) -}
b06ba04c92cd8dadd7efe6f8624e982a
  $fShowFailure3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Failed Test \""#) -}
82fbd8555978daa52f6e486901d331c9
  $fShowFailure_$cshow :: Testing.Failure -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Testing.Failure) ->
                 case ds of wild { Testing.Fail a $dShow s as ->
                 GHC.CString.unpackAppendCString#
                   Testing.$fShowFailure3
                   (GHC.Base.++
                      @ GHC.Types.Char
                      s
                      (GHC.CString.unpackAppendCString#
                         Testing.$fShowFailure2
                         (GHC.Show.showList
                            @ a
                            $dShow
                            as
                            (GHC.Types.[] @ GHC.Types.Char)))) }) -}
82fbd8555978daa52f6e486901d331c9
  $fShowFailure_$cshowList :: [Testing.Failure] -> GHC.Show.ShowS
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Testing.Failure]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Testing.Failure
                   Testing.$fShowFailure1
                   ls
                   s) -}
82fbd8555978daa52f6e486901d331c9
  $fShowFailure_$cshowsPrec ::
    GHC.Types.Int -> Testing.Failure -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><S,1*U><L,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Testing.Failure)
                   (w2 :: GHC.Base.String) ->
                 Testing.$w$cshowsPrec w1 w2) -}
c7dbcd999d9b8ac8d0f2b885eb9f6315
  $tc'Fail :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18363056135848452050##
                   2544067297462416953##
                   Testing.$trModule
                   Testing.$tc'Fail2
                   1#
                   Testing.$tc'Fail1) -}
0f0a37885323d43a8b92e4dbe4004821
  $tc'Fail1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
372ec8b889b6387925838ccdb4f872fd
  $tc'Fail2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Testing.$tc'Fail3) -}
fe10e5bfad69c2c9a48861c344f77548
  $tc'Fail3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Fail"#) -}
8ccee77512aad5e2aa7cc9d47902ed2b
  $tc'Test :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9223971099555393698##
                   4996779694514934970##
                   Testing.$trModule
                   Testing.$tc'Test2
                   1#
                   Testing.$tc'Test1) -}
95a3723335d068bf416e9b767b305785
  $tc'Test1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
490863777ac59ada6402851d0a6cf68a
  $tc'Test2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Testing.$tc'Test3) -}
77a36191c8dddbe0f477ff862c5a20ea
  $tc'Test3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Test"#) -}
85e2421d357548655ba58d47b6a8f5a9
  $tcFailure :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15529291865401267770##
                   11406999788205383722##
                   Testing.$trModule
                   Testing.$tcFailure1
                   0#
                   GHC.Types.krep$*) -}
d6e0937da70e26201f332f95ab5ab3c3
  $tcFailure1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Testing.$tcFailure2) -}
21d7b6a581d7ce1f3d90fbd2e159733f
  $tcFailure2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Failure"#) -}
3f27ff2f9cf84ce930ca991f3e8ccbb8
  $tcTest :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17875211228701042846##
                   1879975042180308559##
                   Testing.$trModule
                   Testing.$tcTest1
                   0#
                   GHC.Types.krep$*) -}
bf1fb60ef0e6caa1fadca09d09e7b13b
  $tcTest1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Testing.$tcTest2) -}
af6558bd452c89f7536861851aa96646
  $tcTest2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Test"#) -}
79e2860f6e6b7f9ea5d4396b56fe686a
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Testing.$trModule3
                   Testing.$trModule1) -}
e2192b3ead6dc5ae42db4a943bb3e7d0
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Testing.$trModule2) -}
309486bc80f3e262ae0d012b7693b1fb
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Testing"#) -}
3ce6be1382daab78e9a9441a9a4fecd5
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Testing.$trModule4) -}
309fcd816e1f59f968444d8cd0d6bdc3
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
82fbd8555978daa52f6e486901d331c9
  $w$cshowsPrec ::
    Testing.Failure -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Testing.Failure) (w1 :: GHC.Base.String) ->
                 case w of wild { Testing.Fail a $dShow s as ->
                 GHC.CString.unpackAppendCString#
                   Testing.$fShowFailure3
                   (GHC.Base.++
                      @ GHC.Types.Char
                      s
                      (GHC.CString.unpackAppendCString#
                         Testing.$fShowFailure2
                         (GHC.Base.++
                            @ GHC.Types.Char
                            (GHC.Show.showList @ a $dShow as (GHC.Types.[] @ GHC.Types.Char))
                            w1))) }) -}
268dd69f0669e57b25d6254db352157d
  $wtestF1 ::
    (GHC.Show.Show b, GHC.Classes.Eq b) =>
    GHC.Base.String -> (a -> b) -> [(a, b)] -> Testing.Test
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(C1(U))),A,A)><L,U(C(C1(U)),A)>, Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: GHC.Show.Show b)
                   (w1 :: GHC.Classes.Eq b) ->
                 let {
                   lvl :: (b, b) -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U(1*U,1*U)>,
                        Unfolding: InlineRule (1, True, False)
                                   (\ (p :: (b, b)) ->
                                    GHC.Classes.==
                                      @ b
                                      w1
                                      (case p of wild { (,) x ds -> x })
                                      (case p of wild { (,) ds y -> y })) -}
                   = \ (p :: (b, b)) ->
                     GHC.Classes.==
                       @ b
                       w1
                       (case p of wild { (,) x ds -> x })
                       (case p of wild { (,) ds y -> y })
                 } in
                 let {
                   $dShow :: GHC.Show.Show (b, b) = GHC.Show.$fShow(,) @ b @ b w w
                 } in
                 \ (s :: GHC.Base.String) (f :: a -> b) (l :: [(a, b)]) ->
                 Testing.Test
                   @ (b, b)
                   $dShow
                   s
                   lvl
                   (GHC.Base.map
                      @ (a, b)
                      @ (b, b)
                      (Control.Arrow.$cfirst @ a @ b @ b f)
                      l)) -}
d7d3d00fc09ce213752b15a7b20dc814
  $wtestF2 ::
    (GHC.Show.Show c, GHC.Classes.Eq c) =>
    GHC.Base.String -> (a -> b -> c) -> [(a, b, c)] -> Testing.Test
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(C1(U))),A,A)><L,U(C(C1(U)),A)>, Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ c
                   (w :: GHC.Show.Show c)
                   (w1 :: GHC.Classes.Eq c) ->
                 let {
                   lvl :: (c, c) -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U(1*U,1*U)>,
                        Unfolding: InlineRule (1, True, False)
                                   (\ (p :: (c, c)) ->
                                    GHC.Classes.==
                                      @ c
                                      w1
                                      (case p of wild { (,) x ds -> x })
                                      (case p of wild { (,) ds y -> y })) -}
                   = \ (p :: (c, c)) ->
                     GHC.Classes.==
                       @ c
                       w1
                       (case p of wild { (,) x ds -> x })
                       (case p of wild { (,) ds y -> y })
                 } in
                 let {
                   $dShow :: GHC.Show.Show (c, c) = GHC.Show.$fShow(,) @ c @ c w w
                 } in
                 \ (s :: GHC.Base.String) (f :: a -> b -> c) (l :: [(a, b, c)]) ->
                 Testing.Test
                   @ (c, c)
                   $dShow
                   s
                   lvl
                   (GHC.Base.map
                      @ (a, b, c)
                      @ (c, c)
                      (\ (ds :: (a, b, c)) ->
                       case ds of wild { (,,) x y z -> (f x y, z) })
                      l)) -}
4e8032649339e826a90aed98dfb84210
  $wtestF3 ::
    (GHC.Show.Show d, GHC.Classes.Eq d) =>
    GHC.Base.String
    -> (a -> b -> c -> d) -> [(a, b, c, d)] -> Testing.Test
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(C1(U))),A,A)><L,U(C(C1(U)),A)>, Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ c
                   @ d
                   (w :: GHC.Show.Show d)
                   (w1 :: GHC.Classes.Eq d) ->
                 let {
                   lvl :: (d, d) -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U(1*U,1*U)>,
                        Unfolding: InlineRule (1, True, False)
                                   (\ (p :: (d, d)) ->
                                    GHC.Classes.==
                                      @ d
                                      w1
                                      (case p of wild { (,) x ds -> x })
                                      (case p of wild { (,) ds y -> y })) -}
                   = \ (p :: (d, d)) ->
                     GHC.Classes.==
                       @ d
                       w1
                       (case p of wild { (,) x ds -> x })
                       (case p of wild { (,) ds y -> y })
                 } in
                 let {
                   $dShow :: GHC.Show.Show (d, d) = GHC.Show.$fShow(,) @ d @ d w w
                 } in
                 \ (s :: GHC.Base.String)
                   (f :: a -> b -> c -> d)
                   (l :: [(a, b, c, d)]) ->
                 Testing.Test
                   @ (d, d)
                   $dShow
                   s
                   lvl
                   (GHC.Base.map
                      @ (a, b, c, d)
                      @ (d, d)
                      (\ (ds :: (a, b, c, d)) ->
                       case ds of wild { (,,,) w2 x y z -> (f w2 x y, z) })
                      l)) -}
82fbd8555978daa52f6e486901d331c9
  data Failure where
    Fail :: GHC.Show.Show a => GHC.Base.String -> [a] -> Failure
31678c69a349f57434d82ed2e0c27ab1
  data Test where
    Test :: GHC.Show.Show a =>
            GHC.Base.String -> (a -> GHC.Types.Bool) -> [a] -> Test
0ca757c5d2fae4238435aff664bdf899
  runTest :: Testing.Test -> GHC.Base.Maybe Testing.Failure
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Testing.Test) ->
                 case ds of wild { Testing.Test a $dShow s f as ->
                 case GHC.List.filter
                        @ a
                        (\ (x :: a) ->
                         case f x of wild1 {
                           GHC.Types.False -> GHC.Types.True
                           GHC.Types.True -> GHC.Types.False })
                        as of wild1 {
                   [] -> GHC.Base.Nothing @ Testing.Failure
                   : ipv ipv1
                   -> GHC.Base.Just
                        @ Testing.Failure
                        (Testing.Fail @ a $dShow s wild1) } }) -}
1d714874d704f2f97c04a2a733d58089
  runTests :: [Testing.Test] -> [Testing.Failure]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: [Testing.Test]) ->
                 Data.Maybe.catMaybes1
                   @ Testing.Failure
                   (GHC.Base.build
                      @ (GHC.Base.Maybe Testing.Failure)
                      (\ @ b1
                         (c :: GHC.Base.Maybe Testing.Failure -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ Testing.Test
                         @ b1
                         (GHC.Base.mapFB
                            @ (GHC.Base.Maybe Testing.Failure)
                            @ b1
                            @ Testing.Test
                            c
                            Testing.runTest)
                         n
                         x))) -}
38834bb0c45f875a23636507d8accb9d
  testF1 ::
    (GHC.Show.Show a, GHC.Show.Show b, GHC.Classes.Eq b) =>
    GHC.Base.String -> (a -> b) -> [(a, b)] -> Testing.Test
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,A><L,U(C(C1(C1(U))),A,A)><L,U(C(C1(U)),A)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ @ a
                   @ b
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Show.Show b)
                   (w2 :: GHC.Classes.Eq b) ->
                 Testing.$wtestF1 @ a @ b w1 w2) -}
d69b8ffdc3c08bd173a0ea9e52a5ee86
  testF2 ::
    (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c,
     GHC.Classes.Eq c) =>
    GHC.Base.String -> (a -> b -> c) -> [(a, b, c)] -> Testing.Test
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><L,A><L,U(C(C1(C1(U))),A,A)><L,U(C(C1(U)),A)>,
     Inline: [0],
     Unfolding: InlineRule (4, True, True)
                (\ @ a
                   @ b
                   @ c
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Show.Show b)
                   (w2 :: GHC.Show.Show c)
                   (w3 :: GHC.Classes.Eq c) ->
                 Testing.$wtestF2 @ a @ b @ c w2 w3) -}
61b47038f91b6f704a67897455c61459
  testF3 ::
    (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c,
     GHC.Show.Show d, GHC.Classes.Eq d) =>
    GHC.Base.String
    -> (a -> b -> c -> d) -> [(a, b, c, d)] -> Testing.Test
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,A><L,A><L,A><L,U(C(C1(C1(U))),A,A)><L,U(C(C1(U)),A)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, True)
                (\ @ a
                   @ b
                   @ c
                   @ d
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Show.Show b)
                   (w2 :: GHC.Show.Show c)
                   (w3 :: GHC.Show.Show d)
                   (w4 :: GHC.Classes.Eq d) ->
                 Testing.$wtestF3 @ a @ b @ c @ d w3 w4) -}
instance [safe] GHC.Show.Show [Testing.Failure]
  = Testing.$fShowFailure
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

